/**
 * File:
 *   include/XXpkgXX/ui.ycp
 *
 * Package:
 *   Configuration of XXpkgXX
 *
 * Summary:
 *   User interface functions.
 *
 * Authors:
 *   XXmaintainerXX <XXemailXX>
 *
 * $Id$
 *
 * All user interface functions.
 *
 */

{

textdomain "XXpkgXX";

import "Wizard";
import "Wizard_hw";
import "Progress";
import "XXPkgXX";

include "ui/common_popups.ycp";
include "ui/common_messages.ycp";
include "wizard/sequencer.ycp";

include "XXpkgXX/helps.ycp";

/**
 * Whole configuration of XXpkgXX
 * @return any Returned value from WizardSequencer() call
 */
global define any XXPkgXXSequence () ``{
    map aliases =
	$[
	    "read"	: [ ``( ReadDialog () ), true ],
	    "main"	:   ``( MainSequence () ),
	    "write"	: [ ``( WriteDialog () ), true ]
	];

    map sequence = $[
	"ws_start" : "read",
	"read" :
	$[
	    `abort	: `abort,
	    `next	: "main"
	],
	"main" :
	$[
	    `abort	: `abort,
	    `next	: "write"
	],
	"write" : $[
	    `abort	: `abort,
	    `next	: `next
	]
    ];

    string caption = _("XXPkgXX configuration");
    term contents = `Label (_("Initializing ..."));

    Wizard::CreateDialog ();
    Wizard::SetContentsButtons ( caption,
				contents,
				"",
				BackButtonLabel (),
				NextButtonLabel ());

    any ret = WizardSequencer (aliases, sequence);

    UI::CloseDialog ();
    return ret;
}

/**
 * Whole configuration of XXpkgXX but without reading and writing.
 * For use with autoinstallation.
 * @return any Returned value from WizardSequencer() call
 */
global define any XXPkgXXAutoSequence () ``{
    string caption = _("XXPkgXX configuration");
    term contents = `Label (_("Initializing ..."));

    Wizard::CreateDialog ();
    Wizard::SetContentsButtons ( caption,
				contents,
				"",
				BackButtonLabel (),
				NextButtonLabel ());

    // Run the main configuration workflow
    any ret = MainSequence ();

    UI::CloseDialog ();
    return ret;
}

/**
 * Main workflow of the XXpkgXX configuration
 * @return any Returned value from WizardSequencer() call
 */
global define any MainSequence () ``{
    // TODO FIXME: adapt the following to your needs!
    map aliases =
	$[
	    "detected"	:   ``( DetectedDialog () ),
	    "overview"	:   ``( OverviewDialog () ),
	    "configure"	: [ ``( AddSequence () ), true ],
	    "add"	: [ ``( AddSequence () ), true ],
	    "edit"	: [ ``( AddSequence () ), true ]
	];

    // TODO FIXME: adapt the following to your needs!
    map sequence = $[
	"ws_start" : "detected",
	"detected" :
	$[
	    `abort	: `abort,
	    `next	: `next,
	    `configure_button: "configure",
	    `edit_button: "overview"
	],
	"overview" :
	$[
	    `abort	: `abort,
	    `next	: `next,
	    `add_button	: "add",
	    `edit_button: "edit"
	],

	"configure" :
	$[
	    `abort	: `abort,
	    `next	: "detected",
	],
	"add" :
	$[
	    `abort	: `abort,
	    `next	: "overview",
	],
	"edit" :
	$[
	    `abort	: `abort,
	    `next	: "overview",
	]
    ];

    any ret = WizardSequencer (aliases, sequence);

    return ret;
}

/**
 * Add a configuration of XXpkgXX
 * @return any Returned value from WizardSequencer() call
 */
global define any AddSequence () ``{
    // TODO FIXME: adapt the following to your needs!
    map aliases =
	$[
	    "config1"	: ``( Configure1Dialog () ),
	    "config2"	: ``( Configure2Dialog () )
	];

    // TODO FIXME: adapt the following to your needs!
    map sequence = $[
	"ws_start" : "config1",
	"config1" :
	$[
	    `abort	: `abort,
	    `next	: "config2"
	],
	"config2" :
	$[
	    `abort	: `abort,
	    `next	: `next
	]
    ];

    return WizardSequencer ( aliases, sequence );
}

/**
 * Read settings dialog
 * @return symbol `next if success, else `abort
 */
global define symbol ReadDialog () ``{
    // Set help text
    Wizard::RestoreHelp (ReadDialogHelp ());

    // A callback function for abort
    block callback = ``{
	return UI::PollInput () == `abort;
    };

    // Read the configuration
    boolean was_ok = XXPkgXX::Read ( callback );

    // TODO FIXME possibly handle the abort

    return ( was_ok? `next : `abort );
}

/**
 * Write settings dialog
 * @return symbol `next if success, else `abort
 */
global define symbol WriteDialog () ``{
    // Set help text
    Wizard::RestoreHelp (WriteDialogHelp ());

    // A callback function for abort
    block callback = ``{
	return UI::PollInput () == `abort;
    };

    // Read the configuration
    boolean was_ok = XXPkgXX::Write ( callback );

    // TODO FIXME possibly handle the abort

    return ( was_ok? `next : `abort );
}

/**
 * Main dialog
 * @return any Returned value from UserInput() call
 */
global define any DetectedDialog () ``{
    string caption = _("XXPkgXX setup");
    // TODO FIXME modify the following according to your needs
    term contents =
	Wizard_hw::DetectedContent (_("XXPkgXX to configure"),
				   [],
				   false,
				   XXPkgXX::Summary ());

    Wizard::SetContentsButtons ( caption,
				contents,
				DetectedDialogHelp (),
				BackButtonLabel (),
				FinishButtonLabel () );

    any ret = nil;
    while (true)
    {
	ret = UI::UserInput ();
	if (ret == `abort)
	{
	    // TODO FIXME: check for change of the configuration
	    if ( UI::ReallyAbortPopup ( true ) )
		break;
	    else
		continue;
	}
	else
	{
	    /* TODO FIXME: your code ... */
	    break;
	}
    };

    return ret;
}

/**
 * Overview dialog
 * @return any Returned value from UserInput() call
 */
global define any OverviewDialog () ``{
    string caption = _("XXPkgXX overview");
    // TODO FIXME: real data for the table
    term contents =
						 // For translators: Header of the table with installed cards
	Wizard_hw::ConfiguredContent ( `header ( _("Number"),
						 // For translators: Header of the table with installed cards
						 _("XXPkgXX")),
						 [],
						 nil, nil, nil, nil );
    contents = Wizard_hw::SpacingAround ( contents, 1.5, 1.5, 1.0, 1.0 );


    Wizard::SetContentsButtons ( caption,
				contents,
				OverviewDialogHelp (),
				BackButtonLabel (),
				FinishButtonLabel () );

    any ret = nil;
    while (true)
    {
	ret = UI::UserInput ();
	if (ret == `abort)
	{
	    // TODO FIXME: check for change of the configuration
	    if ( UI::ReallyAbortPopup ( true ) )
		break;
	    else
		continue;
	}
	else
	{
	    /* TODO FIXME: your code ... */
	    break;
	}
    };

    return ret;
}

/**
 * Configure1 dialog
 * @return any Returned value from UserInput() call
 * TODO FIXME: A more descriptive name for the dialog
 */
global define any Configure1Dialog () ``{
    // TODO FIXME: real configuration workflow
    string caption = _("XXPkgXX configure1");
    term contents = `Label (_("First part of configuration of XXpkgXX"));

    Wizard::SetContentsButtons ( caption,
				contents,
				Configure1DialogHelp (),
				BackButtonLabel (),
				NextButtonLabel () );

    any ret = nil;
    while (true)
    {
	ret = UI::UserInput ();
	if (ret == `abort)
	{
	    // TODO FIXME: check for change of the configuration
	    if ( UI::ReallyAbortPopup ( true ) )
		break;
	    else
		continue;
	}
	else
	{
	    /* TODO FIXME: your code ... */
	    break;
	}
    };

    return ret;
}

/**
 * Configure2 dialog
 * @return any Returned value from UserInput() call
 * TODO FIXME: A more descriptive name for the dialog
 */
global define any Configure2Dialog () ``{
    // TODO FIXME: real configuration workflow
    string caption = _("XXPkgXX configure2");
    term contents = `Label (_("Second part of configuration of XXpkgXX"));

    Wizard::SetContentsButtons ( caption,
				contents,
				Configure2DialogHelp (),
				BackButtonLabel (),
				NextButtonLabel () );

    any ret = nil;
    while (true)
    {
	ret = UI::UserInput ();
	if (ret == `abort)
	{
	    // TODO FIXME: check for change of the configuration
	    if ( UI::ReallyAbortPopup ( true ) )
		break;
	    else
		continue;
	}
	else
	{
	    /* TODO FIXME: your code ... */
	    break;
	}
    };

    return ret;
}

}
