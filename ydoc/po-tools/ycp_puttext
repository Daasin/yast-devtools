#!/usr/bin/perl -w
#
# ycp_puttext -	reverse xgettext for YCP files.
#		Takes a (English) .po-file and patches the translated texts
#		(presumably in better English than the program author's)
#		into a YCP script.
#
# Author: Stefan Hundhammer <sh@suse.de>

use strict;
use English;
use Getopt::Std;
use vars qw( $opt_v $opt_d );


# Global variables.

my $verbose		= 0;
my $debug		= 0;


my %trans;		# translations:		$trans{"orig"} = "translated";
my %trans_ref_count;	# reference counts:	$trans_ref_count{"orig"} = 4;

# The reference counts will be increased as the .po file is being read
# in and decreased as the .ycp file is being patched. After the .ycp
# file is processed, all reference counts should be zero.
#
# If they are not - happy bug hunting ;-)
#
# If the reference count mechanism complains about invalid reference
# counts, more often than not the source code contains the texts to be
# translated in commented-out code. Is this a bug or not? Decide on
# your own. This script, however, will do its work even in such
# commented-out code no matter what - even if it complains.


# Call the main function and exit.
# DO NOT enter any other code outside a sub!
#
# This is not just to satisfy C programmers - rather, this is intended
# to keep global things like the variables above apart from main
# program (local) variables. It is just too easy to mix things up; one
# simple 'i' variable in the main program might too easily be mixed up
# with a function's forgotten 'i' declaration.

main();
exit 0;


#-----------------------------------------------------------------------------


# Main program.

sub main()
{
    my $ycp_file;
    my $po_file;

    # Extract command line options.
    # This will set a variable opt_? for any option,
    # e.g. opt_v if option '-v' is passed on the command line.

    getopts('vd');

    $verbose	= 1 if $opt_v;
    $debug	= 1 if $opt_d;

    $ycp_file = shift @ARGV or usage();
    $po_file  = shift @ARGV or usage();

    ycp_puttext ( $ycp_file, $po_file );
}


#-----------------------------------------------------------------------------

# Process one YCP file:
# Take the translations from $po_file and patch them into $ycp_file.
#
# Parameters:
#	$ycp_file
#	$po_file

sub ycp_puttext()
{
    my ( $ycp_file, $po_file ) = @_;
    my $tmp = "$ycp_file.tmp";
    
    open ( PO, $po_file    ) or die "FATAL: Can't open $po_file";
    read_po();
    close ( PO );

    if ( $opt_d )
    {
	print "Read translations:\n";
	dump_translations();
	print "\n--- Translations end ---\n\n\n";
    }


    open ( IN, $ycp_file ) or die "FATAL: Can't open $ycp_file";
    open ( OUT, "> $tmp" ) or die "FATAL: Can't open $tmp";

    replace_ycp_messages ( $ycp_file );

    close ( OUT );
    close ( IN );

    dump_trans_refs( $po_file, 1 );

    # rename ( $ycp_file, $ycp_file. ".old" );
    # rename ( $tmp, $ycp_file ) or warning ( "Can't rename $tmp to $src" );

    undef %trans;
    undef %trans_ref_count;
}


#-----------------------------------------------------------------------------

# Read a gettext .po-file and store its contents in some (global) hashes:
#	%trans			the translations themselves
#	%trans_ref_count	reference count for each translation
# 
# Parameters: ---

sub read_po()
{
    my @line_numbers;
    my $msgid;
    my $msgstr;
    my $in_msgid  = 0;
    my $in_msgstr = 0;
    my $multi_line = 0;
    my $line;
    my @line_no_infos;
    my $line_no_info;

    while ( $line = <PO> )
    {
	if ( $line =~ '^#:' )	# line number info:
	{			#   #: xy/abc.ycp:123 xy/abc.ycp:456
	    $in_msgid  = 0;
	    $in_msgstr = 0;

	    # process the last translation, if there is any
	    # since there is no real end-of-record delimiter
	    # in gettext format, the next occurence of line number infos
	    # is the loop end condition.

	    if ( defined $msgstr )
	    {
		store_translation ( $msgid, $msgstr, @line_numbers );
		undef @line_numbers;
		undef $msgid;
		undef $msgstr;
		$multi_line = 0;
	    }

	    $line =~ s/^#://;
	    @line_no_infos = split ( '\s+', $line );

	    foreach $line_no_info ( @line_no_infos )
	    {
		push @line_numbers, ( split ( ':', $line_no_info, 2 ) ) [1];
	    }
	}
	elsif ( $line =~ /^#/ )		# comment line?
	{
	    next;			# -> skip
	}
	elsif ( $line =~ /^msgid/ )
	{
	    $in_msgid  = 1;
	    $in_msgstr = 0;

	    if ( $line =~ /^msgid ""/ )
	    {
		$multi_line = 1 
	    }
	}
	elsif ( $line =~ /^msgstr/ )
	{
	    $in_msgid  = 0;
	    $in_msgstr = 1;
	}

	my $quoted_string = $line;
	chomp $quoted_string;	
	$quoted_string =~ s:^[^"]*"(.*)".*$:$1:;	# "] (for emacs)
		     
	if ( $in_msgid )
	{
	    $msgid .= $quoted_string;
	}
        if ( $in_msgstr )
	{
	    if ( $multi_line && defined $msgstr && length ( $msgstr ) > 0 )
	    {
		$msgstr .= "\n";
	    }

	    $msgstr .= $quoted_string;
	}
    }

    # process the last translation

    if ( length ( $msgstr ) > 0 )
    {
	store_translation ( $msgid, $msgstr, @line_numbers );
    }
}


#-----------------------------------------------------------------------------

# Store a (non zero) translation in the internal hashes.
# Empty translations will be silently ignored.
#
# Parameters:
#	$msgid		the original message
#	$msgstr		the translated message
#	@line_numbers	the line numbers where this translation occurs

sub store_translation()
{
    my ( $msgid, $msgstr, @line_numbers ) = @_;
    my $line_no;
    $msgid = normalize ( $msgid );

    return if ( length ( $msgid ) == 0 );

    $trans{ $msgid } = $msgstr;
    $trans_ref_count{ $msgid } = $#line_numbers + 1;
}


#-----------------------------------------------------------------------------

# Process one .ycp file:
# Replace all messages marked for translation - as in _("orig") - with
# the translated texts from the .po file.
#
# Parameters:
#	$ycp_file_name	file name of the .ycp file (for error logging)


sub replace_ycp_messages()
{
    my ( $ycp_file_name ) = @_;
    my $src;
    my $head;
    my $msg;
    my $norm_msg;
    my $line;

    # read the entire input file

    while ( $line = <IN> )
    {
	$src .= $line;
    }

    # warn for invalid lines like:
    #     _( 
    #       // comment
    #       "bla blurb..."
    #
    #     _( 
    #       /* comment */
    #       "bla blurb..."

    if ( $src =~ m:(_\(\s*//.*)":ms ||
	 $src =~ m:(_\(\s*/\*.*)":ms )
    {
	warning ( "WARNING: $ycp_file_name contains comments in texts to translate:\n\n",
		  shorten ( $1, 2*80 ), 
		  "\n\nThis text will most likely be ignored!\n" );
    }


    # parse input file

    while ( defined $src && length ( $src ) > 0 )
    {
	# split src at first message beginning: _("

	( $head, $src ) = split ( /_\(\s*"/ms, $src, 2 );	# ") for emacs
	print OUT $head;
	
	if ( defined $src && length ( $src ) > 0 )		# any message found?
	{
	    # split src at message end: ")

	    ( $msg, $src ) = split ( /"\s*\)/ms, $src, 2 );	# ") for emacs
	    $norm_msg = normalize ( $msg );
	    
	    if ( defined $trans{ $norm_msg } )
	    {
		if ( ! defined $trans_ref_count{ $norm_msg } || $trans_ref_count{ $norm_msg } < 1 )
		{
		    warning ( "WARNING: Invalid reference count for \"" .  shorten ( $msg, 50 ) . "\"" );
		}
		else
		{
		    $trans_ref_count{ $norm_msg }--;
		}

		if ( length( $trans{ $norm_msg } ) > 0 )
		{
		    $msg = $trans{ $norm_msg };
		    logf ( "Inserting \"" . shorten ( $msg, 50 ) . "\"" );
		}
		else
		{
		    deb ( "Don't have a translation for \"" . shorten ( $msg, 50 ) . "\"" );
		}
	    }
	    else
	    {
		warning ( "\nERROR: Unknown message: \n\n\"" . $msg . "\"\n" );
		deb ( "\nNormalized: \n\"" . $norm_msg . "\"\n\n" );
	    }

	    print OUT '_("' . $msg . '")';
	}
    }
}


#-----------------------------------------------------------------------------


# Normalize a string used as msgid
#
# Parametes:
#	$str	string to normalize
#
# Return value:
#	normalized string

sub normalize()
{
    my ( $str ) = @_;

    $str =~ s/\\"//g;	# [" for emacs] remove embedded escaped quotes
    $str =~ s/\\\n/ /g; # replace escaped newline with one blank
    $str =~ s/\\n/ /g;	# replace embedded newline symbols '\n' with one blank
    $str =~ s/\s+/ /g;  # replace all whitespace (including newline) with one blank
    $str =~ s/^\s+//;	# remove all leading whitespace
    $str =~ s/\s+$//;	# remove all trailing whitespace

    return $str;
}


#-----------------------------------------------------------------------------


# For debugging: dump internally stored data

sub dump_all()
{
    my ( $po_file ) = @_;

    dump_trans_refs( $po_file, 0 );
    dump_translations();
}


sub dump_translations()
{
    my $msgid;

    print "\n\n";

    foreach $msgid ( sort keys %trans )
    {
	print "*** msgid: ***\n";
	print $msgid;
	print "\n---> msgstr:\n";
	print $trans{ $msgid };
	print "\n---\n\n";
    }
}


sub dump_trans_refs()
{
    my ( $po_file, $threshold ) = @_;
    my $msgid;
    my $msg;

    foreach $msgid ( sort keys %trans_ref_count )
    {
 	print "$po_file: Reference count for \"" . shorten ( $msgid, 50 ) . "\": $trans_ref_count{ $msgid }\n"
	    unless $trans_ref_count{ $msgid } <= $threshold;
    }
}


#-----------------------------------------------------------------------------

# Shorten a message to max $len characters
#
# Return value: Shortened message

sub shorten()
{
    my ( $msg, $len ) = @_;
    $msg  = substr ( $msg, 0, $len ) . "..." if ( length ( $msg ) > $len );
    
    return $msg;
}


#-----------------------------------------------------------------------------


# Log a message to stderr.
#
# Parameters:
#	Messages to write (any number).

sub warning()
{
    my $msg;

    foreach $msg ( @_ )
    {
	print STDERR $msg . " ";
    }

    print STDERR "\n";
}


#-----------------------------------------------------------------------------


# Log a message to stdout if verbose mode is set
# (command line option '-v').
#
# Parameters:
#	Messages to write (any number).

sub logf()
{
    my $msg;

    if ( $verbose )
    {
	foreach $msg ( @_ )
	{
	    print $msg . " ";
	}

	print "\n";
    }
}


#-----------------------------------------------------------------------------


# Log a debugging message to stdout if debug mode is set
# (command line option '-d').
#
# Parameters:
#	Messages to write (any number).

sub deb()
{
    my $msg;

    if ( $debug )
    {
	print '   DEB> ';

	foreach $msg ( @_ )
	{
	    print $msg . " ";
	}

	print "\n";
    }
}


#-----------------------------------------------------------------------------


# Print usage message and abort program.
#
# Parameters:
#	---

sub usage()
{
    die "Usage: $0 [-vd] <infile.ycp> <po-file>";
}



# EOF
