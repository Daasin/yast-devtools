#!/usr/bin/perl

# Documentation generator. 
# Torben Weis (weis@kde.org) and Sirtaj Kang (taj@kde.org)
# $Id$

#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

###########################################################
#
# Global Variables
#
###########################################################

# system options
require 5.000;

# Look for include files in the same directory as this
# script is.

if ($0 =~ /\//) { 
  unshift @INC, ($0 =~ /(.*)\/.*/)[0];
}

require Ast;

# User options

$dontDoPrivate	= 1;
$strictParser	= 0;
$documentAll	= 1;
$docDeprecated	= 1;
$docInternal	= 1;
$debug		= 0;
$docPath	= ".";
$urlBase	= "";
$libPath	= ".";
$lib		= "";
$genHTML	= 0;
$genTeX		= 0;
$quiet		= 0;

$intro          = "";

# running environment
($version = '$Revision$') =~ tr/\$//d;
$thisHost = `uname -n`;
chop $thisHost;
$user = `whoami`;
chop $user;
$generatedByText = 'YaST2 Developers Documentation';


$libPath = $ENV{'KDOCLIBS'} if $ENV{'KDOCLIBS'} ne "";

# globals - for method

$text = "";
$paramText = "";
$retText = "";
$see = "";
$filename = "";
$class = "";
$inheritance = "";
$paramText = "";
$methodIsInternal = 0;
$methodIsDeprecated = 0;

# for class 
$classShortText = "";
$classShortTextSet = 0;
$classIsInternal = 0;
$classIsDeprecated = 0;
$classText = "";
$classSee = "";
$classAuthor = "";
$classVersion= "";

%classRef = ();
%classSource = ();
@headerList = ();

$line = "";

%noErr = ();
$noErr{ "void" } = 1;
$noErr{ "int" } = 1;
$noErr{ "uint" } = 1;
$noErr{ "uchar" } = 1;
$noErr{ "short" } = 1;
$noErr{ "ushort" } = 1;
$noErr{ "unsignedint" } = 1;
$noErr{ "unsignedchar" } = 1;
$noErr{ "unsignedshort" } = 1;
$noErr{ "float" } = 1;
$noErr{ "double" } = 1;
$noErr{ "short" } = 1;
$noErr{ "char" } = 1;
$noErr{ "unsigned" } = 1;
$noErr{ "bool" } = 1;
$noErr{ "long" } = 1;
$noErr{ "string" } = 1;

# for main

$i = 0;
@myargs = @ARGV;

%children = ();
%parents = ();

# "<>" is the root of all classes.
$children{"<>"} = ";";
$parents{"<>"} = "<>";

$rootNode = Ast::New("ROOT");

####
#
# Function addClass
# 	Inserts a class into the heirarchy
####

sub addClass
{
	local($parent, $child) = @_;

	$parents{ $child } = $parent;

	$children{ $parent } = $child.";".$children{ $parent };

	$childen{ $child } = ";" if !defined $children{ $child };
}

###########################################################
#
# Function
#  readLibrary
#
###########################################################

sub readLibrary
{
    local( $libname ) = @_;
    local( $prefix );
    local( $libFull );

    $libFull = $libPath."/".$libname.".kdoc";

    open( IMP, "$libFull" ) 
    	|| die "Could not open ".$libFull." for reading\n";

    $prefix = <IMP>;
    chop $prefix;

    while ( <IMP> )
    {
	chop;
	if ( /^(.*)=(.*)$/ )
	{
	    $classRef{ $1 } = $prefix . "$2";
	}
	if( /^(\w+)=/ ) {
		# add classes to external list
		$classSource{ $1 } = $libname;
	}
    }

    close( IMP );
}

###########################################################
#
# Function
#  processClass
#
###########################################################

sub processClass
{
    local( $end, $end2 );
    local( $access );
    local( $paramFlag, $retFlag );

    $access = "private";
    $paramFlag = 0;
    $retFlag = 0;
    $classIsDeprecated = 0;
    $classIsInternal = 0;

    %paramDesc = ();
    $paramName = "";
    $paramText = "";
    $retText = "";
    $text = "";
    $see = "";

	print KDOC "$class=$class.html\n";
	$classRef{ "$class" } = "$class.html";

    $classNode = Ast::New( $class );

    $rootNode->AddPropList( "classes", $classNode );

	# use first line of text as short text if we have none yet.
	if( $classShortText eq "" && $classText ne "" ) {
		$_ = $classText;
		/((\s|\w|[^.\n])*)\.*/;
		$classShortText = $1." ";
		$classShortTextSet = 1;
	}

	$classNode->AddProp( "ClassShort", $classShortText );

# escape paths
    $_ = $inheritance;
    tr/\:\{//d;
    s/protected//g;
    s/private//g;
    s/public//g;
    if ( !( /^\s*$/ ) )
    {
	foreach $c ( split /,/, $_ )
	{
	    $c =~ s/\s//g;
		addClass( $c, $class );

		$inheritNode = Ast::New($c);
		$classNode->AddPropList( "Ancestors", $inheritNode );
	}

    }
    else {
	addClass( "<>", $class );	
	}

    while ( <IN> )
    {
	$line = $_;

	if ( /^\s*\}\s*;\s*(\/\/.*)?$/ )
	{
# end of class declaration
# dump all stored stuff to file
	
		$filename =~ s/^\s*$//g;
		$classAuthor =~ s/^\s*$//g;
		$classVersion =~ s/^\s*$//g;
		$classText =~ s/^\s*$//g;
		$classSee =~ s/^\s*$//g;

	    $classNode->AddProp("Header", $filename );
	    $classNode->AddProp("Author", $classAuthor );
	    $classNode->AddProp("Version", $classVersion );
	    $classNode->AddProp("Description", $classText );
	    $classNode->AddProp("See", $classSee );


	    $classSee = "";
	    $classText = "";
	    $classShortText = "";
		$classShortTextSet = 0;
		$classAuthor = "";
		$classVersion= "";
		$classIsDeprecated = 0;
		$classIsInternal = 0;
	    return;
	}
	elsif ( /^\s*public:\s*$/ && $access ne "public" )
	{
	    $access = "public";
	}
	elsif ( /^\s*protected:\s*$/ && $access ne "protected" )
	{
	    $access = "protected";
	}
	elsif ( /^\s*private:\s*$/ && $access ne "private" )
	{
		$access = "private";
	}
	elsif ( /^\s*signals:\s*$/ && $access ne "signals" )
	{
	    $access = "signals";
	}
	elsif ( /^\s*protected\s+slots:\s*$/ && $access ne "protected_slots" )
	{
	    $access = "protected_slots";
	}
	elsif ( /^\s*public\s+slots:\s*$/ && $access ne "public_slots" )
	{
	    $access = "public_slots";
	}
	elsif ( /^\s*private\s+slots:\s*$/ && $access ne "private_slots" )
	{
		$access = "private_slots";
	}

	#### Enum

	elsif ( /^\s*enum\s+([\w_]*)\s*\{(.*)/ )
	{
	    $enum = $1;
	    $tmp = $2;
	    $args = "";

		print KDOC "$class\:\:$1=$class".".html#$1\n";
		$classRef{ "$class\:\:$1" } = $class . ".html#$1";

	    while ( !($tmp =~ /\}/) )
	    {
		$args = $args . $tmp;
		$tmp = <IN>;
	    }
	    $_ = $tmp;
	    /^(.*)\}/;
	    $args = $args . $1;

		$see =~ s/^\s*$//g;
		$text =~ s/^\s*$//g;
		$args =~ s/^\s*$//g;

	    	$newNode = Ast::New( $enum );
		$classNode->AddPropList( $access, $newNode );
		$newNode->AddProp( "Keyword", "enum" );
		$newNode->AddProp( "Description", $text );
		$newNode->AddProp( "See", $see );
		$newNode->AddProp( "Constants", $args );

	    $paramText = "";
	    $retText = "";
	    $text = "";
	    $see = "";
	}

	#### parse out Q_OBJECT macro
	elsif ( /^\s*Q_OBJECT[^\w]+/ ) {
		# dont do anything
	}

	#### Variables

	elsif ( /^[^\(]*$/ && /^[\w_\:\s]+[\&\s*]+[\w_]+\s*;\s*$/ )
	{
	    $str = $_;
	    
	    $str =~ /^(.*)([\s&\s\*])([\w_]*)\s*;\s*$/;
	    $var = $3;
	    $rest = $1.$2;

		print KDOC "$class\:\:$3=$class".".html#$3\n";
		$classRef{ "$class\:\:$3" } = $class . ".html#$3";

		$rest =~ s/^\s*$//g;
		$see =~ s/^\s*$//g;
		$text =~ s/^\s*$//g;

		$newNode = Ast::New( $var );
		$classNode->AddPropList( $access, $newNode );
		$newNode->AddProp( "Keyword", "property" );
		$newNode->AddProp( "Type", $rest );
		$newNode->AddProp( "Description", $text );
		$newNode->AddProp( "See", $see );

	    $paramText = "";
	    $retText = "";
	    $text = "";
	    $see = "";

	}

	elsif ( /^\s*\/\/\/\s*(.*)/  && ($strictParser == 0) ) {
		# DOC++ style "///" single-line member doccer
		# will be used only if no other documentation exists.
		$paramText	="";
		$paramName	= "";
		%paramDesc	= ();

		$retText	="";
		$text		= $1;
		$see		="";
		print "DOCXX-STYLE: $text\n" if $debug == 1;
	}
	elsif ( /^\s*\/\// )
	{
		# parse out comment
	}
	elsif ( /^\s*\/\*\*\s*(.*)\*+\/\s*/ && ($strictParser == 0) ) {
		# single-line "/**..*/" type doc line
		# not allowed by the spec but we'll let it pass 
		# if we're being lenient.

		$paramText	="";
		$paramName	="";
		%paramDesc		=();

		$retText	="";
		$see		="";
		$text		= $1;
		print "ONELINE: $text\n" if $debug == 1;
	}
	elsif( /^\s*\/\*[^*]/ ) {
		# (multiline) comment
		while( !/\*\// ) {
			# skip lines till we find its end
			$_ = <IN>;
		}
	}
	#### Member Function

	elsif ( /^\s*([^\(]*)\s+([^\s]+)\s*\((.*)$/ ) 
	{
	    $t1 = $1." "; # return type
	    $t2 = $2; # Method name
	    $tmp = $3;

		print KDOC "$class\:\:$2=$class".".html#$2\n";
		$classRef{ "$class\:\:$2" } = $class . ".html#$2";

# ensure that "*" is part of return type
		
	    if( $t2 =~ /^\s*([\*|\&]+)(.*)$/ ) {
		    $t1 = $t1.$1;
		    $t2 = $2;
	    }

	    $constness="";

	    ## Read the parameters ($3 onward)

	    $params = "";

	    while ( !($tmp =~ /^[^)]*\)(.*)/) )
	    {
	    	print "SEARCHING: $tmp\n" if $debug == 1;
		$params = $params . $tmp;
		$tmp = <IN>;
	    }
    		$restOfLine = $1;
		$_ = $tmp;
		/^([^)]*)\)/;
		$params = $params . $1;


	    if( $restOfLine =~ /^\s*const/ ) {
	    	$constness = "const";
	    }

	    # need to skip inline function if it is there, or if the
	    # end of declaration is staggered for some other reason.

		if( ! /\)(\s|\w)*;/ )
		{
			# probably unterminated as yet
			print "INLINE: $_\n" if $debug == 1;

			$_ = $tmp;
			$foundMemberEnd = 0;
			$lookingFor = ";";

			while( $foundMemberEnd == 0 )
			{
				print "INLINE looking in: $_\n" if $debug == 1;

				$lookingFor = "\}" if /\{/;
				
				if ( /$lookingFor/ ) 
				{
					$foundMemberEnd = 1;
				}
				else
				{
					$_ = <IN>;
				}
			}
		}

		$t1		=~ s/^\s*$//g;
		$see		=~ s/^\s*$//g;
		$text		=~ s/^\s*$//g;
		$retText	=~ s/^\s*$//g;
		$params		=~ s/^\s*$//g;
		$constness	=~ s/^\s*$//g;
		
		$newNode = Ast::New( $t2 );
		$classNode->AddPropList( $access, $newNode );
		$newNode->AddProp( "ReturnType", $t1 );
		$newNode->AddProp( "Const", $constness );
		$newNode->AddProp( "Parameters", $params );
		$newNode->AddProp( "Keyword", "method" );
		$newNode->AddProp( "Description", $text );
		$newNode->AddProp( "Returns", $retText );
		$newNode->AddProp( "See", $see );

		foreach $param ( keys %paramDesc ) {
			$paramNode = Ast::New( $param );
			($desc = $paramDesc{$param}) =~ s/^\s*$//g;
			$paramNode->AddProp("Description", $desc );

			$newNode->AddPropList( "ParamDoc", $paramNode );
		}

	    $paramText	= "";
	    $paramName	= "";
	    %paramDesc	= ();

	    $retText = "";
	    $text = "";
	    $see = "";
	}
	elsif ( /^\s*\/\*\*+\s*(.*)/ ) {
	# member documentation begins

	    $paramText = "";
	    $paramName	= "";
	    %paramDesc	= ();    
	    
	    $retText = "";
	    $see = "";
	    $lastLineBlank = 0;

	    # allow documentation on first line only if
	    # we're being lenient.

	    if( $strictParser == 0 ) {
		    $text = $1;
	    }
	    else {
	    	    $text = "";
	    }
		

	    $end2 = 0;
	    while ( $end2 == 0 )
	    {
		$_ = <IN>;
		$line = $_;

		if ( $paramFlag == 1 )
		{
		    if ( /^\s*\**\s*\@/ || /^\s*\**\s*\*\// )
		    {
			#parameter ends.
			$paramDesc{ $paramName } = $paramText;
			$paramFlag = 0;
		    }
		    else
		    {
			/^\s*\**(.*)$/;
			$paramText .= $1."\n";
			$_ = "";
		    }
		}
		elsif ( $retFlag == 1 )
		{
		    if ( /^\s*\**\s*\@/ || /^\s*\**\s*\*\// )
		    {
			$retFlag = 0;
		    }
		    else
		    {
			/^\s*\*+(.*)$/;
			$retText .= "\n$1";
			$_ = "";
		    }
		}

		if ( /^\s*(.*)\*+\// )
		{
			# end of member documentation
		    $end2 = 1;
		}
		elsif ( /^(.*)\*+\/\s*$/ && ($strictParser == 0) ) {
# end of member documentation, with extraneous
# space before end tag
# only used if we're being lenient.

			$text = $text .  $_ . '\n';

			$end2 = 1;

			print "BAD MEMBER END: $_\n" if $debug == 1;
		}
		elsif ( /^\s*\**\s*\@param\s+([^\s]+)\s(.*)$/ )
		{
			# "@param"

			$paramName = $1;
			$paramText = $2;

			$paramFlag = 1;
		}
		elsif ( /^\s*\**\s*\@return\s+(.*)/ )
		{
			# "@return"

		    $retText = $1;
		    $retFlag = 1;
		}
		elsif( /^\s*\**\s*\@internal/ )
		{
			# "@internal"
			$methodIsInternal = 1;
		}
		elsif( /^\s*\**\s*\@deprecated/ )
		{
			# "@deprecated"
			$methodIsDeprecated = 1;
		}
		elsif ( /^\s*\**\s*\@see\s+([:#\w_~]+)/ )
		{
			# "@see"
		    if ( $see ne "" )
		    {
			$see = $see . ", ";
		    }
		    $c = $1;
		    $see = $see . $c . "\n";
		}
		elsif( /^\s*\**\s*\@(short|author|version)/ )
		{
			#ignore tags that cannot exist in
			# member doc
		}
		elsif ( /^\s*\**(.*)$/ )
		{
			# normal member documentation text,
			# " * blah blah"

			$text = $text. $1 . "\n";
		} # if
	    } # while
	}
    }
} # processClass
    
###########################################################
#
# Function
#  processFile #
###########################################################

sub processFile
{
	while ( <IN> )
	{
	    $line = $_;
	
	    if ( /^\s*\/\*\*\*\s*(.*)$/ ) # intro
	      {
		$end = 0;
		while ( $end == 0 )
		  {
		    $_ = <IN>;
		    $line = $_;
		    
		    if ( /^\s*\*\// )
		      {
		    	# end of intro
			$end = 1;
		      }
		    elsif ( /^\s*\*\s*(.*)$/ )
		      {
			$intro = $intro . $1 . "\n";
		      }
		  }
	      }

	    elsif ( /^\s*\/\*\*\s*(.*)\*\/\s*/ && ($strictParser == 0) ) {
	      # single-line "/**..*/" type doc line
	      # not allowed by the spec but we'll let it pass 
	      # if we're being lenient.
	      $classSee = "";
	      $classText = $1;
	      $classShortText = $1;
	      print "ONELINE classdoc: $text\n" if $debug == 1;
	    }
	    elsif ( /^\s*\/\*\*\s*(.*)$/ )
	      {
	    	# start of class doc comment
		$classSee = "";
		$classText = "";
		$classShortText = "";
		$lastLineBlank = 0;

		$classText = $1 if( $strictParser == 0 );

		$end = 0;
		while ( $end == 0 )
		{
		    $_ = <IN>;
		    $line = $_;

		    if ( /^\s*\*\// )
		    {
		    	# end of documentation, assume class
			# declaration is next.
			$end = 1;
		    }
		    elsif ( /^(.*)\**\/\s*$/ && ($strictParser == 0) ) 
		    {
			# end of class documentation, with extraneous
			# space before end tag
			# only used if we are being lenient.

			$text = $text .  $1 . '\n';

			$end = 1;

			print "BAD CLASSDOC END: $_\n" if $debug == 1;
		    }
		    elsif ( /^\s*\**\s*\@see\s+([#\w_~]+)/ )
		    {
		    	# @see
			if ( $classSee ne "" )
			{
			    $classSee = $classSee . ", ";
			}
			$c = $1;
			$classSee = $classSee . $c . "\n";
		    }
		    elsif ( /^\s*\*?\s*\@author\s+(.*)/ )
		    {
		    	# @author
		    	$classAuthor = $classAuthor . $1 . " ";
		    }
		    elsif ( /^\s*\**\s*\@version\s+(.*)/ )
		    {
		    	# @version
		    	$classVersion = $classVersion . $1 . " ";
		    }
		    elsif ( /^\s*\**\s*\@short\s+(.*)/ )
		    {
		    	# @short
			$classShortText = $classShortText . $1 . " ";
		    }
		    elsif ( /^\s*\**\s*\@deprecated/ )
		    {
		    	# @deprecated
			$classIsDeprecated = 1;
		    }
		    elsif ( /^\s*\**\s*\@internal/ )
		    {
		    	# @internal
			$classIsInternal = 1;
		    }
		    elsif ( /^\s*\**(.*)$/ )
		    {
		    	# normal documentation text

			$classText .= $1 . "\n";
		    }
		}
                $_ = <IN>;
		$line = $_;
			       
	    } # document if
	    	if( $debug == 1 && /^\s*class\s+([\w_]+)\s*$/ ) {
			print "Found Class: $1\n";
		}
		if ( !(/;/) && /^\s*(template.*\s+)?class\s+([\w_]+)(.*)$/ )
		{
			# class declaration begins.

			#TODO: skip class if it doesn't have documentation
			#and we aren't documenting NULL classes.

		    $class = $2;
		    $inheritance = $3;

		    print " $class " unless $quiet;
		    print KDOC "$class=$class".".html\n";

# process everything in the class
		    processClass();

			$classShortText = "";
		}
	} # outer file while

	close( IN );
}

sub usage
{
die<<EOF;

YDOC:   The YaST2 Class Documentation Tool.
        This is almost 100% KDOC, but with a few changes
        by Mathias Kettner <kettner\@suse.de>

        The original source of kdoc can be found on the
        SuSE distribution in the package 'kdoc', serial 'kpa'
        or on ftp.suse.com

KDOC:	The KDE Class Documentation Tool for C++, $version
	Torben Weis <weis\@kde.org>, Sirtaj Kang <taj\@kde.org>

Usage:
	ydoc [-a] [-X][-H] [-p] [-q] [-L<lib-path>] [-d<outdir>] 
		[-u <base URL>] <library> <headers> [-llib ... ]

	-d<dir> Directory for HTML output.
	-u<url> Base path/url by which this library will be accessed.
	
	-a	Document methods/classes without explicit doc comment.
	-e	Skip deprecated methods and classes (\@deprecated tag)
	-i	Skip classes marked internal (\@internal tag)
	-p	Document private members.
	-q	Proceed quietly (display errors only)

	-L<dir>	Path to ydoc libraries. Default is current dir, or
		\$KDOCLIBS if it is set.

	<library> The name of the ydoc library to create.
	<headers> C++ headers to process.

	-l<lib>	Cross reference these libraries.
EOF
}

sub bumpArg
{
	return $1 if $1 ne "";
	local($real);

	$i = $i + 1;

	$real = $myargs[ $i ];
	$myargs[ $i ] = "-".$myargs[ $i ];


	return $real;
}


###########################################################
#
# Main
#
###########################################################

if ( $#ARGV == -1 )
{
	die "ydoc: No arguments. Type 'ydoc -h' for help.\n";
}

#
# process switches and args #
#

$libFoundAt = -1;

$i = 0;

while( $i <=$#myargs )
{
    $filename = $myargs[ $i ];
    if ( $filename =~ /^-d(.*)$/ ) {

	$docPath = bumpArg();
    }
    elsif ( $filename =~ /^-u(.*)$/ ) {
    	$urlBase= bumpArg();
    }
    elsif ( $filename =~ /^-L(.*)$/ ) {
	$libPath = bumpArg();    	
    }
    elsif ( $filename =~ /^-l(.*)$/ ) {
   	readLibrary( bumpArg() );
    }
    elsif ( $filename =~ /^-a/ ) {
    	$documentAll = 1;
    }
    elsif ( $filename =~ /^-H/ ) {
	    $genHTML = 1;
	    require ydocHTML;
    }
    elsif ( $filename =~ /^-e/ ) {
   	$docDeprecated = 0; 
    }
    elsif ( $filename =~ /^-i/ ) {
   	$docInternal = 0; 
    }
    elsif ( $filename =~ /^-p/ ) {
    	$dontDoPrivate = 0;
    }
    elsif ( $filename =~ /^-q/ ) {
    	$quiet = 1;
    }
    elsif( $filename =~ /^-v(.*)/  ) {
    	die "kdoc: $version (c) Torben Weis, Sirtaj S. Kang\n";
    }
    elsif( $filename =~ /^-h/ || $filename =~ /^--help/ )
    {
    	usage();
    }
    elsif( $filename =~ /^-(.*)/ ) {
    	die "ydoc: -$1 is an unsupported option. Type ydoc -h for help.\n";
    }
    elsif( $lib eq "" ) {
    	$lib = $filename;
	$libFoundAt = $i;
    }

    $i = $i + 1;
}

if ( $urlBase eq "" ) {
	$urlBase = $docPath;
}

if( $lib eq "" ) {
	usage();
}

#parse out path name for printed libName
( $name = $lib ) =~ s#.*/##g;

$lib = $libPath."/".$lib.".kdoc";

open( KDOC, ">$lib" ) || die "Could not open $lib for writing\n";
print KDOC "$urlBase\n";


# check document output path

if( !(-d $docPath))
{
	if( system("mkdir $docPath") ) {
		close ( KDOC );
		unlink( $lib );
		die "Document path '$docPath' doesn't exist and it couldn't\n".
			"be created.\n";
	}
}

#
# process loop #
#

foreach $i (0..$#myargs)
{
    $filename = $myargs[ $i ];
    if ( $filename =~ /^-(.*)$/ )
    {
#option... don't process    	
    }
    elsif( $i != $libFoundAt )
    {
	print "Processing $filename:" unless $quiet;
	push( @headerList, $filename );
	open( IN, $filename ) || die "Could not open $filename for input\n";

	processFile();

	print "\n" unless $quiet;

	close( IN );
    }
}


close( KDOC );

# reparent all parentless classes to root.

$rootNode->Visit("main");

if( defined $classes ) {

	foreach $class ( @{$classes} )
	{
		$className = $class->{"astNodeName"};

		if ( !defined $parents{ $parents{$className} }) {
			addClass( "<>", $parents{$className} );
		}
	}
}

Ast::UnVisit();
 
if( $genHTML == 0 && $genTeX == 0 )
{
	$genHTML = 1;
	require ydocHTML;
}

if( $genHTML != 0 ) {
	kdocHTML::dumpDoc( $name, $rootNode, $docPath );
}

if( $genTeX != 0 ) {
	kdocTeX::dumpDoc( $name, $rootNode, $docPath );
}

print "Done.\n" unless $quiet;
